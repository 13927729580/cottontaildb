package org.vitrivr.cottontail.database.queries.planning

import org.vitrivr.cottontail.database.queries.planning.basics.NodeExpression
import org.vitrivr.cottontail.database.queries.planning.basics.NodeRewriteRule
import java.util.*

/**
 * This is a rather simple query planner that optimizes a [NodeExpression] by recursively applying
 * a set of [NodeRewriteRule]s to get more sophisticated yet equivalent [NodeExpression]s.
 *
 * @author Ralph Gasser
 * @version 1.0
 */
class CottontailQueryPlanner(vararg val rules: NodeRewriteRule = emptyArray()) {

    /**
     * Generates a list of equivalent [NodeExpression]s by recursively applying [NodeRewriteRule]s
     * on the seed [NodeExpression] and derived [NodeExpression]. The level of recursion and the number
     * of candidates to consider per level can be configured.
     *
     * @param expression The [NodeExpression] to optimize.
     * @param recursion The depth of recursion before final candidate is selected.
     * @param candidatesPerLevel The number of candidates to generate per recursion level.
     */
    fun optimize(expression: NodeExpression, recursion: Int, candidatesPerLevel: Int): Collection<NodeExpression> {
        val candidates = mutableListOf<NodeExpression>()
        if (recursion > 0) {
            for (e in this.generateCandidates(expression, candidatesPerLevel)) {
                candidates.addAll(this.optimize(e, recursion - 1, candidatesPerLevel))
            }
            candidates.add(expression)
        }
        return candidates
    }


    /**
     * Generates candidate [NodeExpression]s by applying the [CottontailQueryPlanner.rules] to the
     * given [NodeExpression]. Each re-write generated by a [NodeRewriteRule] results in a candidate.
     *
     * @param expression The [NodeExpression] to explore candidates for.
     * @param restrictTo The number of candidates to produce.
     */
    private fun generateCandidates(expression: NodeExpression, restrictTo: Int): Collection<NodeExpression> {
        val candidates = mutableListOf<NodeExpression>()
        val next = LinkedList<NodeExpression>()
        for (rule in this.rules) {
            next.add(expression)
            while (next.peek() != null) {
                val current = next.poll()
                current.parents.forEach { next.offer(it) }
                if (rule.canBeApplied(current)) {
                    val result = rule.apply(current)
                    if (result != null) {
                        candidates.add(result.root)
                    }
                }
            }
        }
        return candidates.sortedBy { it.cost }.take(restrictTo)
    }
}