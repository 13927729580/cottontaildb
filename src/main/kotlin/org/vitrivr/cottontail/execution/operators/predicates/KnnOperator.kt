package org.vitrivr.cottontail.execution.operators.predicates

import org.vitrivr.cottontail.database.queries.components.KnnPredicate
import org.vitrivr.cottontail.execution.ExecutionEngine
import org.vitrivr.cottontail.execution.operators.basics.Operator
import org.vitrivr.cottontail.execution.operators.basics.PipelineBreaker
import org.vitrivr.cottontail.execution.operators.basics.ProducingOperator
import org.vitrivr.cottontail.math.knn.selection.ComparablePair
import org.vitrivr.cottontail.math.knn.selection.MinHeapSelection
import org.vitrivr.cottontail.math.knn.selection.MinSingleSelection
import org.vitrivr.cottontail.math.knn.selection.Selection
import org.vitrivr.cottontail.model.basics.ColumnDef
import org.vitrivr.cottontail.model.basics.Name
import org.vitrivr.cottontail.model.basics.Record
import org.vitrivr.cottontail.model.values.DoubleValue
import org.vitrivr.cottontail.model.values.types.VectorValue
import org.vitrivr.cottontail.utilities.math.KnnUtilities
import java.util.concurrent.Callable

/**
 * Performs a kNN lookup on the input generated by the parent [Operator] using the given [KnnPredicate].
 *
 * This is a [Operator.PipelineBreaker]
 *
 * @author Ralph Gasser
 * @version 1.0
 */
class KnnOperator<T : VectorValue<*>>(parent: ProducingOperator, context: ExecutionEngine.ExecutionContext, val knn: KnnPredicate<T>) : PipelineBreaker(parent, context) {

    override val columns: Array<ColumnDef<*>> = arrayOf(
            *this.parent.columns,
            ColumnDef(this.knn.column.name.entity()?.column(KnnUtilities.DISTANCE_COLUMN_NAME)
                    ?: Name.ColumnName(KnnUtilities.DISTANCE_COLUMN_NAME), KnnUtilities.DISTANCE_COLUMN_TYPE)
    )

    /**
     * Executes the incoming [Operator] of this [KnnOperator] and materializes its results.
     */
    override fun incomingOperator() = Callable {
        /* Prepare data structure for kNN. */
        val knnSet: List<Selection<ComparablePair<Record, DoubleValue>>> = if (this.knn.k == 1) {
            knn.query.map { MinSingleSelection() }
        } else {
            knn.query.map { MinHeapSelection(this.knn.k) }
        }

        /* Prepare the action that is being executed. */
        val action: (Record) -> Unit = if (this.knn.weights != null) {
            {
                val value = it[this.knn.column]
                if (value != null) {
                    this.knn.query.forEachIndexed { i, query ->
                        knnSet[i].offer(ComparablePair(it, this.knn.distance(query, value, this.knn.weights[i])))
                    }
                }
            }
        } else {
            {
                val value = it[this.knn.column]
                if (value != null) {
                    this.knn.query.forEachIndexed { i, query ->
                        knnSet[i].offer(ComparablePair(it, this.knn.distance(query, value)))
                    }
                }
            }
        }

        /* Execute incoming branch. */
        while (!this.parent.depleted) {
            val record = this.parent.next()
            if (record != null) {
                action(record)
            }
        }

        /* Generate recordset from HeapSelect data structures and return it. */
        KnnUtilities.selectToRecordset(this.columns, knnSet)
    }
}