package org.vitrivr.cottontail.execution.operators.predicates

import org.vitrivr.cottontail.database.queries.components.KnnPredicate
import org.vitrivr.cottontail.execution.ExecutionEngine
import org.vitrivr.cottontail.execution.exceptions.OperatorException
import org.vitrivr.cottontail.execution.operators.basics.*
import org.vitrivr.cottontail.math.knn.selection.ComparablePair
import org.vitrivr.cottontail.math.knn.selection.MinHeapSelection
import org.vitrivr.cottontail.math.knn.selection.MinSingleSelection
import org.vitrivr.cottontail.math.knn.selection.Selection
import org.vitrivr.cottontail.model.basics.ColumnDef
import org.vitrivr.cottontail.model.basics.Name
import org.vitrivr.cottontail.model.basics.Record
import org.vitrivr.cottontail.model.recordset.Recordset
import org.vitrivr.cottontail.model.values.DoubleValue
import org.vitrivr.cottontail.utilities.math.KnnUtilities
import java.lang.IllegalStateException
import java.util.concurrent.Callable

/**
 * Performs a kNN lookup on the input generated by the parent [Operator]s using the given [KnnPredicate]. The incoming
 * branches are executed in parallel (if possible).
 *
 * This operator is a [MergingPipelineBreaker]
 *
 * @author Ralph Gasser
 * @version 1.0
 */
class ParallelKnnOperator(parents: List<ProducingOperator>, context: ExecutionEngine.ExecutionContext, val knn: KnnPredicate<*>) : MergingPipelineBreaker(parents, context) {

    /** The columns produced by this [ParallelKnnOperator]. */
    override val columns: Array<ColumnDef<*>> = arrayOf(
        *this.parents.first().columns,
        ColumnDef(this.knn.column.name.entity()?.column(KnnUtilities.DISTANCE_COLUMN_NAME)
                ?: Name.ColumnName(KnnUtilities.DISTANCE_COLUMN_NAME), KnnUtilities.DISTANCE_COLUMN_TYPE)
    )

    /** [ParallelKnnOperator]s are operational if all their parent [Operator]s are operational. */
    override val operational: Boolean
        get() = this.parents.all { it.operational }

    /** [ParallelKnnOperator]s are depleted, once they have returned all records. */
    override val depleted: Boolean
        get() = this.returned > this.cache?.rowCount ?: Long.MAX_VALUE

    /** Number entries returned by this [ParallelKnnOperator]. */
    private var returned = 0L

    /** The cached [Recordset]. */
    private var cache: Recordset? = null

    /* Data structure for kNN. */
    private val knnSet: List<Selection<ComparablePair<Record, DoubleValue>>> = if (this.knn.k == 1) {
        this.knn.query.map { MinSingleSelection() }
    } else {
        this.knn.query.map { MinHeapSelection(this.knn.k) }
    }

    /** Action that is being executed by this [ParallelKnnOperator]. */
    private val action: (Record) -> Unit = if (this.knn.weights != null) {
        {
            val value = it[this.knn.column]
            if (value != null) {
                this.knn.query.forEachIndexed { i, query ->
                    knnSet[i].offer(ComparablePair(it, this.knn.distance(query, value, this.knn.weights[i])))
                }
            }
        }
    } else {
        {
            val value = it[this.knn.column]
            if (value != null) {
                this.knn.query.forEachIndexed { i, query ->
                    knnSet[i].offer(ComparablePair(it, this.knn.distance(query, value)))
                }
            }
        }
    }

    init {
        /* Sanity check; columns must be the same for all parents. */
        if (!this.parents.all { it.columns.contentEquals(this.parents.first().columns) }) {
            throw OperatorException("Error during setup of ParallelKnnOperator; columns produced by incoming branches are not the same.")
        }
    }

    /** Implementation of [Operator.open] */
    override fun open() {
        check(this.status == OperatorStatus.CREATED) { "Cannot open operator that is in state ${this.status}." }

        /* Call parents. */
        this.parents.forEach { it.open() }

        /* Update status. */
        this.status = OperatorStatus.OPEN
    }

    /** Implementation of [ProducingOperator.next] */
    override fun next(): Record? {
        check(this.status == OperatorStatus.OPEN) { "Cannot call next() on an operator that is in state ${this.status}." }

        /* Checks if cache is null and triggers execution of incoming operators, if true. */
        if (this.cache == null) {
            val branches = this.incomingUnitOperators()
            this.context.executeBranches(branches)
            this.cache = KnnUtilities.selectionsToRecordset(this.columns, this.knnSet)
        }

        /* Return next entry. */
        return this.getNext()
    }

    override fun getNext(): Record? = this.cache!![this.returned++]

    /** Implementation of [Operator.close] */
    override fun close() {
        check(this.status == OperatorStatus.OPEN) { "Cannot close operator that is state ${this.status}." }

        /* Call parents. */
        this.parents.forEach { it.close() }

        /* Execute preparation. */
        this.cache = null

        /* Update status. */
        this.status = OperatorStatus.CLOSED
    }

    /**
     * Produces a [Callable] for each incoming branch and returns it.
     *
     * @return List of [Callable] for each incoming branch.
     */
    fun incomingUnitOperators(): List<Callable<Unit>> = this.parents.map {
        Callable {
            /* Execute incoming branch. */
            while (!it.depleted) {
                val record = it.next()
                if (record != null) {
                    this.action(record)
                }
            }
        }
    }


    /**
     * Acccessing this method on [ParallelKnnOperator] is actually illegal.
     */
    override fun incomingOperators(): List<Callable<Recordset>> {
        throw IllegalStateException("Cannot call incomingOperators() on ParallelKnnOperator")
    }
}